
# henry.smith@ukaea.uk


import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import matplotlib.axes as axes
import matplotlib.patches as patches
import glob
from pathlib import Path

#defines
filepath = 'N:/CCFE/H3AT/TritiumScience/Tritium Research/Tricem/Data/Science/ScienceRun3-D2/S87\*' #write the filepath, and at the end, include '*' - can't end in a \
smoothfactor =3

daqXcolumn = 0 			#UNUSED. seems we increments seconds by 1s each timestep, so range() will work
daqYcolumns = [2,3,4,5] 	#all columns in each sheet of the doc that contain Y data
daqYcolumnsb = [2,3,4,5] #the header can sometimes be misaligned because pandas automatically throws away row 1 if there are more columns than headers
daqheaderrow = 7 				#row of the header (i.e the column titles)

diodeXcolumn = 0 			#only column in each sheet of the doc that contains the x data. This is the sample data column, giving us Time in Seconds
diodeYcolumn = 1 # columnthat contains Y data
diodeheaderrow = 0 				#row of the header (i.e the column titles)

rXcolumn =0 #UNUSED. seems we increments seconds by 1s each timestep, so range() will work and will be faster.
rYcolumn =1
rheaderrow = 0
resistorohms =1234

colours = ("Yellow", "Green", "Blue", "Red", "Orange", "Purple", "Black", "Teal",
           "rosybrown", "salmon", "darkgoldenrod", "lightseagreen", "darkolivegreen", "saddlebrown", "cornflowerblue",
          "fuchsia", "grey", "darkslategray", "navy", "royalblue", "lightgreen", "mediumseagreen") #will cycle through this index colouring each new graph in a new colour
noisebound = 10 # if the absolute value is less than the noise boundary, the data point is treated as noise


#Command defines

def getcontentx(i, colno):
    data = pd.read_excel(i, sheet_name = 0, usecols = [colno], header = header_row)
    indexeddata = [list(x) for x in zip(*data.values)]
    x = pd.Series(indexeddata[0]).rolling(window=10).mean()
    plt.xlabel(data.columns[0])  	# column header becomes the x axis title. You can replace this with any string you like.
    return x

def plotYandreturnlegendvalues(i, colnos):
    data = pd.read_excel(i, sheet_name = 0, usecols = colnos, header = header_row)
    indexeddata = [list(x) for x in zip(*data.values)] #pulls out the data
    legendvalues = (data.columns)
    print (legendvalues)
    for column in range(len(colnos)): 
        y = pd.Series(indexeddata[column]).rolling(window=smoothfactor).mean() 		#pulls out a column in the data
        plt.plot(x, y, color =colours[column], linewidth = 1.5, alpha = 0.7) #  There's a lot of options here, e.g 'o' means it plots as dots. you may want to add 'color =colours[each], ' - this will then use the colours specified in defines
    return legendvalues 

def plotandsave(titlestring,ystring,xstring,yv):
    plt.title(titlestring)
    if yv is not False:
        plt.axis(ymin=yv)
    plt.ylabel(ystring) 			#defines labels for your graph. "D flux (N m⁻²s⁻ˡ)"
    plt.xlabel(xstring) 
    plt.rcParams.update({"savefig.facecolor":  ('white'),"figure.figsize": (14, 10)})  			#big nice pngs
    plt.savefig(titlestring, bbox_inches='tight') #this will throw a bunch of .png files into the folder specified in filepath, overwriting anything with the same name.
    plt.show()				#shows you the graph that was saved

def loadfirstfilematching(name):
    filefind = ''.join([filepath, name])
    files = glob.glob(filefind)
    print ('Began reading', files[0])
    return files[0]
    
    
# The Actual Script

###daq
daqfile = loadfirstfilematching("daq.csv")
daqdata = pd.read_csv(daqfile, header=daqheaderrow)
datavalues = [list(x) for x in zip(*daqdata.values)]
datalabels = daqdata.columns
print(datalabels)
x = range(len(datavalues[0]))

for each in daqYcolumns:
    y = pd.Series(datavalues[each]).rolling(window=smoothfactor).mean()
    plt.plot(x, y, color =colours[each], linewidth = 1.5, alpha = 0.7)
plt.legend(datalabels[daqYcolumnsb], bbox_to_anchor=(1, 1))
titlestring = '.'.join([daqfile[len(daqfile):-8],"Pressure in System" ,"png"])
plotandsave(titlestring,"pressure/V", "Time/S",-8)

###diode
diodefile = loadfirstfilematching("diode.csv")
diodedata = pd.read_csv(diodefile, sep='\t', header=diodeheaderrow)
datavalues = [list(x) for x in zip(*diodedata.values)]
datalabels = diodedata.columns
print(datalabels)
x =  datavalues[diodeXcolumn]
y = pd.Series(datavalues[diodeYcolumn]).rolling(window=smoothfactor).mean()
plt.plot(x, y, color =colours[5], linewidth = 1.5, alpha = 0.7)
plt.legend(datalabels[diodeYcolumns], bbox_to_anchor=(1, 1))
titlestring = '.'.join([diodefile[len(filepath):-10],"light output to diode" ,"png"])
plotandsave(titlestring,"power/W","Time/MS",0)



###r1 and r2
r1file = loadfirstfilematching("R2.csv")
r1data = pd.read_csv(r1file, header=rheaderrow)
datavalues = [list(x) for x in zip(*r1data.values)]
r2 = datavalues[rYcolumn]
r1file = loadfirstfilematching("R1.csv")
r1data = pd.read_csv(r1file, header=rheaderrow) #using r1file for both, to conserve space in the ram lmaooo
datavaluesii = [list(x) for x in zip(*r1data.values)]
r1 = datavaluesii[rYcolumn]
if len(r1)>len(r2):  # discards values from longer file so that r1 and r2 are the same length
    r1 = r1[:len(r2)]
else:
    r2 = r2[:len(r1)]
x = range(len(r1)) #makes a column of integers, counting from 1 up to the end of the file
r1overr2=[]
current=[]
currentr2=[]
for each in x:
    r1overr2.append((r1[each]/r2[each]))
    current.append((r1[each]/resistorohms))
    currentr2.append((r2[each]/resistorohms))
plt.plot(x, r1, color =colours[5], linewidth = 1.5, alpha = 0.7)
plt.plot(x, r2, color =colours[6], linewidth = 1.5, alpha = 0.7)
titlestring = '.'.join([r1file[len(filepath):-7],"R1 vs R2","png"])
plotandsave(titlestring,"power/W", "Time/MS",False)
plt.plot(r1overr2, r1, color =colours[7], linewidth = 1.5, alpha = 0.7)
titlestring = '.'.join([r1file[len(filepath):-7],"R1 ÷ R2 vs R1","png"])
plotandsave(titlestring,"R1/R2", "R1",False)
plt.plot(x, current, color =colours[8], linewidth = 1.5, alpha = 0.7)
plt.legend(datalabels[diodeYcolumn], bbox_to_anchor=(1, 1))
titlestring = '.'.join([r1file[len(filepath):-4],"R2 Current","png"])
plotandsave(titlestring,"power/W", "Time/MS",False)
         
        
        
def findlowerboundofcurve(enumerateddata):
    for each in enumerateddata:
        if (abs(enumerateddata[each])>=noisebound):
            if (each-previous)<10:
                lb.append(each)
                previous = each
                if len(lb)>5:
                    print (lb)
                    return lb
                    break
            else:
                sv=[each]
                previous = each
                
def findupperboundofcurve(enumerateddata, lowerstart):  
    for each in enumerateddata[lowerstart:]:
        if abs(enumerateddata[each])<=noisebound:
            if (each-previous)<10:
                ub.append(each)
                previous = each
                if len(ub)>5:
                    print (ub)
                    return ub
                    break
            else:
                ub=[each]
                previous = each
        
print ('"My work here is done." The python executable revs a big motorcycle and drives away in a cloud of smoke. It lights a cigarette, and gazes wistfully back at you, tears forming in its eyes')
