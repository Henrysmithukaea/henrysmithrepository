from reportlab.lib.utils import ImageReader
from reportlab.pdfgen.canvas import Canvas
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase.pdfmetrics import registerFont
from reportlab.lib.pagesizes import A4

# henry.smith@ukaea.uk


import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import matplotlib.axes as axes
import matplotlib.patches as patches
import glob
import os

#defines
filefolder = 'N:/CCFE/H3AT/TritiumScience/Tritium Research/Tricem/Data/Science/ScienceRun3-D2/' #write the filepath, and at the end, include '*' so the code works.
                                                                                                  # ** is a "wildcard", so it goes through every folder in thesciencerun3-d2 directory 
outputfolder = 'N:\CCFE\H3AT\TritiumScience\Tritium Research\Tricem\Data\Science\ScienceRun3-D2\output'
smoothfactor =3 # smoothing factor for any averaging we do on the graph (there's none atm)

colours = ("Yellow", "Green", "Blue", "Red", "Orange", "lightgreen", "navy", "Teal",
           "purple", "salmon", "darkgoldenrod", "lightseagreen", "darkolivegreen", "saddlebrown", "cornflowerblue",
          "fuchsia", "grey", "darkslategray", "black", "royalblue", "rosybrown", "mediumseagreen") #will cycle through this index colouring each new graph in a new colour


areacm2 = 12.82


### defines for daq
daqXcolumn = 0 			#UNUSED. seems we increments seconds by 1s each timestep, so range() will work
daqtimestep =1
daqYcolumns = [2,3,4,5] 	#all columns in each sheet of the doc that contain Y data
daqYcolumnsb = [2,3,4,5] #the header can sometimes be misaligned because pandas automatically throws away row 1 if there are more columns than headers
daqheaderrow = 7 				#row of the header (i.e the column titles)

### defines for diode
diodeXcolumn = 0 			#only column in each sheet of the doc that contains the x data. This is the sample data column, giving us Time in Seconds
diodeYcolumn = 1 # columnthat contains Y data
diodeheaderrow = 0 				#row of the header (i.e the column titles)

### defines for r comparison
rXcolumn =0 #UNUSED. seems we increments seconds by 1s each timestep, so range() will work and will be faster.7
rtimestep =1
rYcolumn =1
rheaderrow = 0
resistorohms =1

### defines for pdf processor. p.s check derived defines for this
registerFont(TTFont('arial','C:\\windows\\fonts\\arial.ttf'))
img = ImageReader('N:\CCFE\H3AT\TritiumScience\Tritium Research\Tricem\Data\Science\Analysis\Macros\FinalLogo.jpg')
cwidt = 590
cheigh = 785

#derived defines. change ** to a named folder in filepath e.g s87
filepath = ''.join([filefolder,'S87\*'])


#Command defines

def dopdf(canv, listoffiles, assembledstring):
    canv.drawImage(listoffiles[0],10,2*cheigh/3,280,200,anchor='sw',anchorAtXY=True,showBoundary=False)
    canv.drawImage(listoffiles[1],cwidt/2,2*cheigh/3,250,200,anchor='sw',anchorAtXY=True,showBoundary=False)
    if len(listoffiles)>=3:
        canv.drawImage(listoffiles[2],10,(cheigh+15)/3,250,200,anchor='sw',anchorAtXY=True,showBoundary=False)
        if len(listoffiles)>=4:
            canv.drawImage(listoffiles[3],cwidt/2,(cheigh+15)/3,250,200,anchor='sw',anchorAtXY=True,showBoundary=False)
            if len(listoffiles)>=5:
                canv.drawImage(listoffiles[4],10,10,250,200,anchor='sw',anchorAtXY=True,showBoundary=False)
                if len(listoffiles)>=6:
                    canv.drawImage(listoffiles[5],cwidt/2,10,250,200,anchor='sw',anchorAtXY=True,showBoundary=False)
    canv.setFont('arial',14)
    canv.setFillColor((0,0,0)) #change the text color
    canv.drawCentredString(cwidt/2,(2*cheigh/3) +250, assembledstring)
    canv.save()

def plotandsave(titlestring,ystring,xstring,yv): # shows a plot and then saves it as a .png
    plt.title(titlestring)
    if yv is not False:
        plt.axis(ymin=yv)
    plt.ylabel(ystring) 			#defines labels for your graph. "D flux (N m⁻²s⁻ˡ)"
    plt.xlabel(xstring) 
    plt.rcParams.update({"savefig.facecolor":  ('white'),"figure.figsize": (7, 5)})  			#big nice pngs
    savestring = '/'.join([outputfolder, titlestring])
    plt.savefig(savestring, bbox_inches='tight') #this will throw a bunch of .png files into the folder specified in filepath, overwriting anything with the same name.
    plt.show()				#shows you the graph that was saved

def loadfilesmatching(name): # loads files and returns a list of them ordered by name alphabetically
    filefind = ''.join([filepath, name])
    files = sorted(glob.glob(filefind,recursive=True))
    print ('Began reading', files, len(files))
    return files
    
    
# The Actual Script

###daq
daqfiles = loadfilesmatching("daq.csv")
for daqfile in daqfiles:
    daqdata = pd.read_csv(daqfile, header=daqheaderrow)
    datavalues = [list(x) for x in zip(*daqdata.values)]
    datalabels = daqdata.columns
    print(datalabels)
    x = [i*daqtimestep for i in range(len(datavalues[0]))]
    for each in daqYcolumns:
        y = datavalues[each]
        plt.plot(x, y, color =colours[each], linewidth = 1.5, alpha = 0.7)
    plt.legend(datalabels[daqYcolumnsb], bbox_to_anchor=(1, 1))
    titlefile =  os.path.basename(daqfile)
    titlestring = '.'.join([titlefile[:6],"Pressure in System" ,"png"])
    plotandsave(titlestring,"pressure/V", "Time/S",-8)

###diode
diodefiles = loadfilesmatching("diode.csv")
for diodefile in diodefiles:
    diodedata = pd.read_csv(diodefile, sep='\t', header=diodeheaderrow)
    datavalues = [list(x) for x in zip(*diodedata.values)]
    datalabels = diodedata.columns
    print(datalabels)
    x = datavalues[diodeXcolumn]
    y = pd.Series(datavalues[diodeYcolumn]).rolling(window=smoothfactor).mean()
    plt.plot(x, y, color =colours[0], linewidth = 1.5, alpha = 0.7)
    plt.legend(datalabels[diodeYcolumn], bbox_to_anchor=(1, 1))
    titlefile =  os.path.basename(diodefile)
    titlestring = '.'.join([titlefile[:6],"light output to diode" ,"png"])
    plotandsave(titlestring,"power/W","Time/MS",0)



###r1 and r2
r2files = loadfilesmatching("R2.csv")
r1files = loadfilesmatching("R1.csv")# DOES NOT CHECK THE FILES MATCH.
listoffilesr1 =[]
listoffilesr2=[]
meancurrentlist=[]
timelist =[]
for each in range(len(r1files)):
    r1file = os.path.basename(r1files[each])
    r2file = os.path.basename(r2files[each])
    r1data = pd.read_csv(r1files[each], header=rheaderrow)
    datavalues = [list(x) for x in zip(*r1data.values)]
    r1 = datavalues[rYcolumn]
    r2data = pd.read_csv(r2files[each], header=rheaderrow) #using r1file for both, to conserve space in the ram lmaooo
    datavaluesii = [list(x) for x in zip(*r2data.values)]
    r2 = datavaluesii[rYcolumn]
    if len(r1)>len(r2):  # discards values from longer file so that r1 and r2 are the same length
        r1 = r1[:len(r2)]
    else:
        r2 = r2[:len(r1)]
    x = range(len(r1))
    xfloat = [i*rtimestep for i in x] #makes a column, counting from 1 up to the end of the file. Then multiplies all values by a float(set to 1)
    r1overr2=[]
    current=[]
    currentr2=[]
    currenthigh=[]
    for eachh in x:
        if r2[eachh] == 0:
            r1overr2.append(0) # if it can't actually divide by r2, adds 0 instead.
        else:
            r1overr2.append(r1[eachh]/r2[eachh])
        current.append(r1[eachh]/resistorohms)
        currentr2.append(r2[eachh]/resistorohms)
        if r1[eachh]>=0.0001:
            currenthigh.append(r1[eachh]/resistorohms) 
    timelist.append(len(currenthigh)*rtimestep)
    meancurrentlist.append(sum(currenthigh)/len(currenthigh))
    plt.plot(x, r1, color =colours[1], linewidth = 1.5, alpha = 0.7)
    plt.plot(x, r2, color =colours[2], linewidth = 1.5, alpha = 0.7)
    listoffilesr1.append(r1file[:6])
    listoffilesr2.append(r2file[:6])
    titlestring = '.'.join([listoffilesr1[each],"R1 vs R2","png"])
    plotandsave(titlestring,"power/W", "Time/MS",False)
    plt.plot(r1overr2, r1, color =colours[7], linewidth = 1.5, alpha = 0.7)
    titlestring = '.'.join([listoffilesr1[each],"R1 ÷ R2 vs R1","png"])
    plotandsave(titlestring,"R1/R2", "R1",False)
    plt.plot(x, current, color =colours[6], linewidth = 1.5, alpha = 0.7)
    titlestring = '.'.join([listoffilesr1[each],"R2 Current","png"])
    plotandsave(titlestring,"power/W", "Time/MS",False)
print (listoffilesr1)
if not listoffilesr1==listoffilesr2:
    print ('the files used for r1 and r2 do not seem to match', listoffilesr1, listoffilesr2)

for each in range(len(listoffilesr1)):
    file = listoffilesr1[each]
    filepath = ''.join([outputfolder, '/', file, '*' ])
    canvname = ''.join([outputfolder, '/!', file, ' report.pdf'])
    canv = Canvas(canvname,pagesize=A4)
    canv.drawImage(img, 240, cheigh, 240, 55,anchor='sw',anchorAtXY=True,showBoundary=False)
    listoffiles = sorted(glob.glob(filepath,recursive=True))
    seconds = timelist[each]/1000
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    
    stringlist = ['The mean current is', str(meancurrentlist[each]), 'Time(s) is', str(hours),'Hr',str(minutes),'min',str(seconds),'s']
    assembledstring = ' '.join(stringlist)
    print (filepath, listoffiles, assembledstring)
    dopdf(canv, listoffiles, assembledstring)
print ('"My work here is done." The python removes its sunglasses, revealing a pair of slightly smaller sunglasses, and exits the room.')

                       
                               
# Unused defines
noisebound = 10 # if the absolute value is less than the noise boundary, the data point is treated as noise

def findlowerboundofcurve(enumerateddata):
    for each in enumerateddata:
        if (abs(enumerateddata[each])>=noisebound):
            if (each-previous)<10:
                lb.append(each)
                previous = each
                if len(lb)>5:
                    print (lb)
                    return lb
                    break
            else:
                sv=[each]
                previous = each
                
def findupperboundofcurve(enumerateddata, lowerstart):  
    for each in enumerateddata[lowerstart:]:
        if abs(enumerateddata[each])<=noisebound:
            if (each-previous)<10:
                ub.append(each)
                previous = each
                if len(ub)>5:
                    print (ub)
                    return ub
                    break
            else:
                ub=[each]
                previous = each
